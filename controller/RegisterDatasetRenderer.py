import pyldapi
from rdflib import Graph, Namespace, URIRef, Literal, RDF, RDFS, XSD


class RegisterDatasetRenderer(pyldapi.RegisterOfRegistersRenderer):
    """
    Specialised implementation of the RegisterOfRegistersRenderer for adding DCAT v2 properties to the display of
    a Register of Register which is expected to a whole datasets
    """
    def __init__(self, request, uri, label, comment, rofr_file_path, *args,
                 super_register=None, **kwargs):

        # push RofR properties up to the RofR constructor
        super(pyldapi.RegisterOfRegistersRenderer, self).__init__(
            request, uri, label, comment, rofr_file_path, *args, ['http://purl.org/linked-data/registry#Register'],
            super_register=super_register, **kwargs
        )

        # initialise DCAT things
        # from https://w3c.github.io/dxwg/dcat/#Class:Dataset
        # rdf:type dcat:Dataset
        # dataset creator (dct:creator -> foaf:Agent)
        # dataset distribution (dcat:distribution -> dcat:Distribution) could be the SPARQL endpoint, HTML, RDF??
        # frequency (dct:accrualPeriodicity -> dct:Frequency) quarterly?
        # spatial/geographical coverage (dct:spatial -> dct:Location) just Australia from GeoNames? Check class
        # temporal coverage (dct:temporal -> dct:PeriodOfTime) ??
        # was generated by (prov:wasGeneratedBy -> prov:Activity) ?

        # from https://w3c.github.io/dxwg/dcat/#Class:Resource
        # title (dct:title -> rdfs:Literal)
        # description (dct:description -> rdfs:Literal)
        # release data (dct:issued -> rdfs:Literal)
        # update/modification date (dct:modified -> rdfs:Literal)
        # language (dct:language -> dct:LinguisticSystem)
        # publisher (dct:publisher -> foaf:Organization)
        # identifier (dct:identifier -> rdfs:Literal)
        # theme/category (dcat:theme -> skos:Concept)
        # type/genre (dct:type -> rdfs:Class) from http://dublincore.org/documents/dcmi-terms/#section-7
        # conforms to (dct:conformsTo -> dct:Standard). Use a prof:Profile instance as the Object value
        # keyword/tag (dcat:keyword -> rdfs:Literal)
        # contact point  (dcat:contactPoint -> vcard:Kind)
        # landing page (dcat:landingPage -> dcat:landingPage) use the main URI endpoint

        # from https://w3c.github.io/dxwg/dcat/#Class:Data_Distribution_Service
        # rdf:type dcat:DataDistributionService
        # serves dataset (dcat:servesDataset -> at:Dataset) is it sensible when there's only 1?
        # endpoint address (dcat:endpointURL -> xsd:anyURI) the SPARQL endpoint
        # endpoint description (dcat:endpointDescription -> rdfs:Resource) SPARQL RDF description
        # license (dct:license -> dct:LicenseDocument) same as the other Distribution licenses, same as data.gov.au
        # access rights (dct:accessRights -> dct:RightsStatement) same as the other Distribution licenses, same as data.gov.au

        # from https://w3c.github.io/dxwg/dcat/#Class:Distribution
        # license (dct:license -> dct:LicenseDocument) same as the other Distribution licenses, same as data.gov.au
        # access rights (dct:accessRights -> dct:RightsStatement) same as the other Distribution licenses, same as data.gov.au
        # title (dct:title -> rdfs:Literal)
        # description (dct:description -> rdfs:Literal)
        # release data (dct:issued -> rdfs:Literal)
        # update/modification date (dct:modified -> rdfs:Literal)
        # access address (dcat:accessURL -> rdfs:Resource) HTML, RDF etc., using QSA
        # conforms to (dct:conformsTo -> dct:Standard). Use a prof:Profile instance as the Object value
        # media type (dcat:mediaType -> dct:MediaType)

    def _generate_reg_view_rdf(self):
        # first it does all the RofR things, automatically
        # now we add DCAT things
        g = super(pyldapi.RegisterOfRegistersRenderer, self)._generate_reg_view_rdf()
        # REG = Namespace('http://purl.org/linked-data/registry#')
        # for uri_str, cics in self.subregister_cics.items():
        #     uri = URIRef(uri_str)
        #     for cic in cics:
        #         g.add((uri, REG.containedItemClass, cic))
        DCAT = Namespace('http://www.w3.org/ns/dcat#')
        g.bind('dcat', DCAT)
        FOAF = Namespace('http://xmlns.com/foaf/0.1/')
        g.bind('foaf', FOAF)
        DCT = Namespace('http://purl.org/dc/terms/')
        g.bind('dct', DCT)

        register_uri = URIRef(self.uri)
        # from https://w3c.github.io/dxwg/dcat/#Class:Dataset
        # rdf:type dcat:Dataset
        g.add((register_uri, RDF.type, DCAT.Dataset))

        # dataset creator (dct:creator -> foaf:Agent)
        psma = URIRef('http://catalogue.linked.data.gov.au/org/psma')
        g.add((psma, RDF.type, FOAF.Organization))
        g.add((psma, RDFS.label, Literal('PSMA Australia Ltd.')))
        g.add((register_uri, RDF.type, psma))

        # dataset distribution (dcat:distribution -> dcat:Distribution) could be the SPARQL endpoint, HTML, RDF??
        # TODO: DCAT distribution decisions

        # frequency (dct:accrualPeriodicity -> dct:Frequency) quarterly?
        # from https://github.com/AGLDWG/TR/blob/master/lists/aufreq.ttl
        g.add((register_uri, DCT.accrualPeriodicity, URIRef('http://purl.org/cld/freq/quarterly')))

        # spatial/geographical coverage (dct:spatial -> dct:Location) just Australia from GeoNames? Check class
        g.add((register_uri, DCT.spatial, URIRef('http://www.geonames.org/countries/AU/australia')))

        # temporal coverage (dct:temporal -> dct:PeriodOfTime) ??
        # TODO: DCAT temporal coverage

        # was generated by (prov:wasGeneratedBy -> prov:Activity) ?
        # probably no value in implementing this one

        # from https://w3c.github.io/dxwg/dcat/#Class:Resource
        # title (dct:title -> rdfs:Literal)
        g.add((register_uri, DCT.title, Literal(self.label, datatype=XSD.string)))
        # TODO: DCAT remove the RDFS label

        # description (dct:description -> rdfs:Literal)
        g.add((register_uri, DCT.description, Literal(self.comment, datatype=XSD.string)))
        # TODO: DCAT remove the RDFS comment

        # release data (dct:issued -> rdfs:Literal)
        g.add((register_uri, DCT.issued, Literal('2016-02-22', datatype=XSD.date)))  # from data.gov.au

        # update/modification date (dct:modified -> rdfs:Literal)
        g.add((register_uri, DCT.modified, Literal('2018-08-28', datatype=XSD.date)))  # from data.gov.au

        # language (dct:language -> dct:LinguisticSystem)
        g.add((register_uri, DCT.language, URIRef('http://id.loc.gov/vocabulary/iso639-2/eng')))

        # publisher (dct:publisher -> foaf:Organization)
        # same as creator, but also CSIRO
        g.add((register_uri, DCT.publisher, psma))
        csiro = URIRef('http://catalogue.linked.data.gov.au/org/O-000886')
        g.add((csiro, RDF.type, FOAF.Organization))
        g.add((psma, RDFS.label, Literal('CSIRO')))
        g.add((register_uri, RDF.type, psma))
        g.add((register_uri, DCT.publisher, csiro))

        # identifier (dct:identifier -> rdfs:Literal)
        g.add((register_uri, DCT.identifier, Literal('gnaf')))

        # theme/category (dcat:theme -> skos:Concept)
        # TODO: DCAT theming Concepts

        # type/genre (dct:type -> rdfs:Class) from http://dublincore.org/documents/dcmi-terms/#section-7
        g.add((register_uri, DCT.type, URIRef('http://purl.org/dc/dcmitype/Dataset')))

        # conforms to (dct:conformsTo -> dct:Standard). Use a prof:Profile instance as the Object value
        g.add((register_uri, DCT.conformsTo, URIRef('http://linked.data.gov.au/def/gnaf')))
        g.add((register_uri, DCT.conformsTo, URIRef('http://linked.data.gov.au/def/iso19160-1-address')))

        # keyword/tag (dcat:keyword -> rdfs:Literal)
        g.add((register_uri, DCAT.keyword, Literal('G-NAF')))
        g.add((register_uri, DCAT.keyword, Literal('geocoding')))
        g.add((register_uri, DCAT.keyword, Literal('addresses')))

        # contact point  (dcat:contactPoint -> vcard:Kind)
        """
        @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
        @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
        @prefix vcard: <http://www.w3.org/2006/vcard/ns#> .
        @prefix xml: <http://www.w3.org/XML/1998/namespace> .
        @prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
        
        <http://example.com/me/corky> a vcard:Individual ;
            vcard:fn "Corky Crystal" ;
            vcard:hasAddress [ a vcard:Home ;
                    vcard:country-name "Australia" ;
                    vcard:locality "WonderCity" ;
                    vcard:postal-code "5555" ;
                    vcard:street-address "111 Lake Drive" ] ;
            vcard:hasEmail <mailto:corky@example.com> ;
            vcard:hasTelephone [ a vcard:Home,
                        vcard:Voice ;
                    vcard:hasValue <tel:+61755555555> ] ;
            vcard:nickname "Corks" .
        """

        # landing page (dcat:landingPage -> dcat:landingPage) use the main URI endpoint

        return g
