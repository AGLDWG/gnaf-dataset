import pyldapi
from rdflib import Graph, Namespace, URIRef, Literal, RDF, RDFS, XSD, BNode, OWL


class RegisterDatasetRenderer(pyldapi.RegisterOfRegistersRenderer):
    """
    Specialised implementation of the RegisterOfRegistersRenderer for adding DCAT v2 properties to the display of
    a Register of Register which is expected to a whole datasets
    """
    def __init__(self, request, uri, label, comment, rofr_file_path, *args,
                 super_register=None, **kwargs):

        # push RofR properties up to the RofR constructor
        super().__init__(
            request, uri, label, comment, rofr_file_path, *args, ['http://purl.org/linked-data/registry#Register'],
            super_register=super_register, **kwargs
        )

        # initialise DCAT things
        # from https://w3c.github.io/dxwg/dcat/#Class:Dataset
        # rdf:type dcat:Dataset
        # dataset creator (dct:creator -> foaf:Agent)
        # dataset distribution (dcat:distribution -> dcat:Distribution) could be the SPARQL endpoint, HTML, RDF??
        # frequency (dct:accrualPeriodicity -> dct:Frequency) quarterly?
        # spatial/geographical coverage (dct:spatial -> dct:Location) just Australia from GeoNames? Check class
        # temporal coverage (dct:temporal -> dct:PeriodOfTime) ??
        # was generated by (prov:wasGeneratedBy -> prov:Activity) ?

        # from https://w3c.github.io/dxwg/dcat/#Class:Resource
        # title (dct:title -> rdfs:Literal)
        # description (dct:description -> rdfs:Literal)
        # release data (dct:issued -> rdfs:Literal)
        # update/modification date (dct:modified -> rdfs:Literal)
        # language (dct:language -> dct:LinguisticSystem)
        # publisher (dct:publisher -> foaf:Organization)
        # identifier (dct:identifier -> rdfs:Literal)
        # theme/category (dcat:theme -> skos:Concept)
        # type/genre (dct:type -> rdfs:Class) from http://dublincore.org/documents/dcmi-terms/#section-7
        # conforms to (dct:conformsTo -> dct:Standard). Use a prof:Profile instance as the Object value
        # keyword/tag (dcat:keyword -> rdfs:Literal)
        # contact point  (dcat:contactPoint -> vcard:Kind)
        # landing page (dcat:landingPage -> dcat:landingPage) use the main URI endpoint

        # from https://w3c.github.io/dxwg/dcat/#Class:Data_Distribution_Service
        # rdf:type dcat:DataDistributionService
        # serves dataset (dcat:servesDataset -> at:Dataset) is it sensible when there's only 1?
        # endpoint address (dcat:endpointURL -> xsd:anyURI) the SPARQL endpoint
        # endpoint description (dcat:endpointDescription -> rdfs:Resource) SPARQL RDF description
        # license (dct:license -> dct:LicenseDocument) same as the other Distribution licenses, same as data.gov.au
        # access rights (dct:accessRights -> dct:RightsStatement) same as the other Distribution licenses, same as data.gov.au

        # from https://w3c.github.io/dxwg/dcat/#Class:Distribution
        # license (dct:license -> dct:LicenseDocument) same as the other Distribution licenses, same as data.gov.au
        # access rights (dct:accessRights -> dct:RightsStatement) same as the other Distribution licenses, same as data.gov.au
        # title (dct:title -> rdfs:Literal)
        # description (dct:description -> rdfs:Literal)
        # release data (dct:issued -> rdfs:Literal)
        # update/modification date (dct:modified -> rdfs:Literal)
        # access address (dcat:accessURL -> rdfs:Resource) HTML, RDF etc., using QSA
        # conforms to (dct:conformsTo -> dct:Standard). Use a prof:Profile instance as the Object value
        # media type (dcat:mediaType -> dct:MediaType)

    def _generate_reg_view_rdf(self):
        # first it does all the RofR things, automatically
        # now we add DCAT things
        g = super(pyldapi.RegisterOfRegistersRenderer, self)._generate_reg_view_rdf()
        # REG = Namespace('http://purl.org/linked-data/registry#')
        # for uri_str, cics in self.subregister_cics.items():
        #     uri = URIRef(uri_str)
        #     for cic in cics:
        #         g.add((uri, REG.containedItemClass, cic))
        DCAT = Namespace('http://www.w3.org/ns/dcat#')
        g.bind('dcat', DCAT)
        FOAF = Namespace('http://xmlns.com/foaf/0.1/')
        g.bind('foaf', FOAF)
        DCT = Namespace('http://purl.org/dc/terms/')
        g.bind('dct', DCT)
        VCARD = Namespace('http://www.w3.org/2006/vcard/ns#')
        g.bind('vcard', VCARD)
        # PROV = Namespace('http://www.w3.org/ns/prov-o#')
        # g.bind('prov', PROV)

        #
        #   Dataset - https://w3c.github.io/dxwg/dcat/#Class:Dataset
        #
        dataset_uri = URIRef('https://data.gov.au/dataset/geocoded-national-address-file-g-naf')
#         g.add((dataset_uri, RDF.type, DCAT.Dataset))
#         psma = URIRef('http://catalogue.linked.data.gov.au/org/psma')
#         g.add((psma, RDF.type, FOAF.Organization))
#         g.add((psma, RDFS.label, Literal('PSMA Australia Ltd.')))
#         g.add((register_uri, DCT.creator, psma))
#         g.add((register_uri, DCT.accrualPeriodicity, URIRef('http://purl.org/cld/freq/quarterly')))
#         g.add((register_uri, DCT.spatial, URIRef('http://www.geonames.org/countries/AU/australia')))
#         g.add((register_uri, DCT.title, Literal('PSMA Geocoded National Address File (G-NAF)', datatype=XSD.string)))#
#         desc = """The Geocoded National Address File (referred to as G-NAF) is Australia’s authoritative, geocoded address file.
#
# G-NAF is one of the most ubiquitous and powerful spatial datasets. It contains more than 13 million Australian physical address records. The records include geocodes. These are latitude and longitude map coordinates. G-NAF does not contain any names or personal information.
#
# G-NAF is produced by PSMA Australia Limited (PSMA), an unlisted public company formed by the nine governments of Australia to collate and standardise, format and aggregate location data from each of the jurisdictions into authoritative location based national datasets.
#
# This initiative to make the G-NAF openly available has been achieved through collaboration between PSMA and the Commonwealth and State and Territory Governments.
#
# Updated versions of the G-NAF will be published on a quarterly basis from February 2016.
#
# For further information on G-NAF, including FAQs on the data, see: www.psma.com.au/products/g-naf or contact and PSMA’s network of value added resellers and integrators provide a range of commercial products based on G-NAF including software solutions, consultancy and support."""
#         g.add((register_uri, DCT.description, Literal(desc)))
#         # TODO: DCAT remove the RDFS comment
#         g.add((register_uri, DCT.issued, Literal('2016-02-22', datatype=XSD.date)))  # from data.gov.au
#         g.add((register_uri, DCT.modified, Literal('2018-08-28', datatype=XSD.date)))  # from data.gov.au
#         g.add((register_uri, DCT.language, URIRef('http://id.loc.gov/vocabulary/iso639-2/eng')))
#         g.add((register_uri, DCT.publisher, psma))
#         csiro = URIRef('http://catalogue.linked.data.gov.au/org/O-000886')
#         g.add((csiro, RDF.type, FOAF.Organization))
#         g.add((csiro, RDFS.label, Literal('CSIRO')))
#         g.add((register_uri, DCT.publisher, csiro))
#         g.add((register_uri, DCT.identifier, Literal('gnaf')))
#         g.add((register_uri, DCT.type, URIRef('http://purl.org/dc/dcmitype/Dataset')))
#         g.add((register_uri, DCT.conformsTo, URIRef('http://linked.data.gov.au/def/gnaf')))
#         g.add((register_uri, DCT.conformsTo, URIRef('http://linked.data.gov.au/def/iso19160-1-address')))
#         g.add((register_uri, DCAT.keyword, Literal('G-NAF')))
#         g.add((register_uri, DCAT.keyword, Literal('geocoding')))
#         g.add((register_uri, DCAT.keyword, Literal('addresses')))
#         vcard = BNode()
#         g.add((vcard, RDF.type, VCARD.Individual))
#         g.add((vcard, VCARD.fn, Literal("Joseph Abhayaratna")))
#         g.add((vcard, VCARD.hasEmail, URIRef('joseph.abhayaratna@psma.com.au')))
#         g.add((register_uri, DCAT.contactPoint, vcard))
#         g.add((register_uri, DCAT.landingPage, URIRef('http://linked.data.gov.au/dataset/gnaf')))

        #
        #   Distributions - https://w3c.github.io/dxwg/dcat/#Class:Data_Distribution_Service
        #
        vcard2 = BNode()
        g.add((vcard2, RDF.type, VCARD.Individual))
        g.add((vcard2, VCARD.fn, Literal("Nicholas Car")))
        g.add((vcard2, VCARD.hasEmail, URIRef('nicholas.car@csiro.au')))
        phone = BNode()
        g.add((phone, RDF.type, VCARD.Home))
        g.add((phone, VCARD.hasValue, URIRef('tel:+61738335632')))
        g.add((vcard2, VCARD.hasTelephone, phone))

        dist_service = URIRef('http://linked.data.gov.au/dataset/gnaf/sparql')
        g.add((dist_service, RDF.type, DCAT.DataDistributionService))
        g.add((dist_service, DCT.title, Literal('GNAF SPARQL Service')))
        g.add((dist_service, DCT.description, Literal('A SPARQL 1.1 service accessing all of the content of the GNAF in RDF')))
        g.add((dist_service, DCAT.servesDataset, dataset_uri))
        g.add((dist_service, DCAT.endpointURL, dist_service))
        g.add((dist_service, DCAT.endpointDescription, URIRef('http://linked.data.gov.au/dataset/gnaf/sparql.ttl')))
        g.add((dist_service, DCAT.license, URIRef('https://data.gov.au/dataset/19432f89-dc3a-4ef3-b943-5326ef1dbecc/resource/09f74802-08b1-4214-a6ea-3591b2753d30')))
        g.add((dist_service, DCAT.contactPoint, vcard2))

        dist_service2 = URIRef(self.uri)
        g.add((dist_service2, OWL.sameAs, URIRef('http://linked.data.gov.au/dataset/gnaf')))
        g.add((dist_service2, RDF.type, DCAT.DataDistributionService))
        g.add((dist_service2, DCT.title, Literal('GNAF Linked Data API Service')))
        g.add((dist_service2, DCT.description, Literal('A Linked Data API accessing all of the content of the GNAF in RDF & HTML')))
        g.add((dist_service2, DCAT.servesDataset, dataset_uri))
        g.add((dist_service2, DCAT.endpointURL, dist_service2))
        g.add((dist_service2, DCAT.endpointDescription, URIRef('http://linked.data.gov.au/dataset/gnaf.ttl')))
        g.add((dist_service2, DCAT.license, URIRef('https://data.gov.au/dataset/19432f89-dc3a-4ef3-b943-5326ef1dbecc/resource/09f74802-08b1-4214-a6ea-3591b2753d30')))
        g.add((dist_service2, DCAT.contactPoint, vcard2))

        # clean out any leftover properties
        g.remove((dist_service2, RDFS.label, Literal(self.label, datatype=XSD.string)))
        g.remove((dist_service2, RDFS.comment, Literal(self.comment, datatype=XSD.string)))

        return g
