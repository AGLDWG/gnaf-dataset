import pyldapi


class RegisterDatasetRenderer(pyldapi.RegisterOfRegistersRenderer):
    """
    Specialised implementation of the RegisterOfRegistersRenderer for adding dcat:Dataset properties to the display of
    a Register of Register
    """
    def __init__(self, request, uri, label, comment, rofr_file_path, *args,
                 super_register=None, **kwargs):

        # push RofR properties up to the RofR constructor
        super(pyldapi.RegisterOfRegistersRenderer, self).__init__(
            request, uri, label, comment, rofr_file_path, *args, ['http://purl.org/linked-data/registry#Register'],
            super_register=super_register, **kwargs
        )

        # initialise DCAT things
        # from https://w3c.github.io/dxwg/dcat/#Class:Dataset
        # rdf:type dcat:Dataset
        # dataset creator (dct:creator -> foaf:Agent)
        # dataset distribution (dcat:distribution -> dcat:Distribution) could be the SPARQL endpoint, HTML, RDF??
        # frequency (dct:accrualPeriodicity -> dct:Frequency) quarterly?
        # spatial/geographical coverage (dct:spatial -> dct:Location) just Australia from GeoNames? Check class
        # temporal coverage (dct:temporal -> dct:PeriodOfTime) ??
        # was generated by (prov:wasGeneratedBy -> prov:Activity) ?

        # from https://w3c.github.io/dxwg/dcat/#Class:Resource
        # title (dct:title -> rdfs:Literal)
        # description (dct:description -> rdfs:Literal)
        # release data (dct:issued -> rdfs:Literal)
        # update/modification date (dct:modified -> rdfs:Literal)
        # language (dct:language -> dct:LinguisticSystem)
        # publisher (dct:publisher -> foaf:Organization)
        # identifier (dct:identifier -> rdfs:Literal)
        # theme/category (dcat:theme -> skos:Concept)
        # type/genre (dct:type -> rdfs:Class) from http://dublincore.org/documents/dcmi-terms/#section-7
        # conforms to (dct:conformsTo -> dct:Standard). Use a prof:Profile instance as the Object value
        # keyword/tag (dcat:keyword -> rdfs:Literal)
        # contact point  (dcat:contactPoint -> vcard:Kind)
        # landing page (dcat:landingPage -> dcat:landingPage) use the main URI endpoint

        # from https://w3c.github.io/dxwg/dcat/#Class:Data_Distribution_Service
        # rdf:type dcat:DataDistributionService
        # serves dataset (dcat:servesDataset -> at:Dataset) is it sensible when there's only 1?
        # endpoint address (dcat:endpointURL -> xsd:anyURI) the SPARQL endpoint
        # endpoint description (dcat:endpointDescription -> rdfs:Resource) SPARQL RDF description
        # license (dct:license -> dct:LicenseDocument) same as the other Distribution licenses, same as data.gov.au
        # access rights (dct:accessRights -> dct:RightsStatement) same as the other Distribution licenses, same as data.gov.au

        # from https://w3c.github.io/dxwg/dcat/#Class:Distribution
        # license (dct:license -> dct:LicenseDocument) same as the other Distribution licenses, same as data.gov.au
        # access rights (dct:accessRights -> dct:RightsStatement) same as the other Distribution licenses, same as data.gov.au
        # title (dct:title -> rdfs:Literal)
        # description (dct:description -> rdfs:Literal)
        # release data (dct:issued -> rdfs:Literal)
        # update/modification date (dct:modified -> rdfs:Literal)
        # access address (dcat:accessURL -> rdfs:Resource) HTML, RDF etc., using QSA
        # conforms to (dct:conformsTo -> dct:Standard). Use a prof:Profile instance as the Object value
        # media type (dcat:mediaType -> dct:MediaType)

    def _generate_reg_view_rdf(self):
        # first it does all the RofR things, automatically
        # now we add DCAT things
        pass
